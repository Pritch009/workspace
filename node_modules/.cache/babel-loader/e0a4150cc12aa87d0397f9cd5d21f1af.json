{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\nimport { clamp } from '../utils/clamp/clamp.js';\nconst clampUseMovePosition = position => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1)\n});\nfunction useMove(onChange, handlers) {\n  let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ltr\";\n  const ref = useRef();\n  const mounted = useRef(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n  useEffect(() => {\n    const onScrub = _ref => {\n      let {\n        x,\n        y\n      } = _ref;\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = \"none\";\n          const rect = ref.current.getBoundingClientRect();\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove);\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof (handlers == null ? void 0 : handlers.onScrubStart) === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof (handlers == null ? void 0 : handlers.onScrubEnd) === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n    const onMouseDown = event => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n    const onMouseMove = event => onScrub({\n      x: event.clientX,\n      y: event.clientY\n    });\n    const onTouchStart = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      startScrubbing();\n      onTouchMove(event);\n    };\n    const onTouchMove = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n    ref.current.addEventListener(\"mousedown\", onMouseDown);\n    ref.current.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener(\"mousedown\", onMouseDown);\n        ref.current.removeEventListener(\"touchstart\", onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n  return {\n    ref,\n    active\n  };\n}\nexport { clampUseMovePosition, useMove };","map":{"version":3,"sources":["../../src/use-move/use-move.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { useEffect, useState, useRef } from 'react';\nimport { clamp } from '../utils';\n\nexport interface UseMovePosition {\n  x: number;\n  y: number;\n}\n\nexport const clampUseMovePosition = (position: UseMovePosition) => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1),\n});\n\ninterface useMoveHandlers {\n  onScrubStart?(): void;\n  onScrubEnd?(): void;\n}\n\nexport function useMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: useMoveHandlers,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const ref = useRef<T>();\n  const mounted = useRef<boolean>(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n\n  useEffect(() => {\n    const onScrub = ({ x, y }: UseMovePosition) => {\n      cancelAnimationFrame(frame.current);\n\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = 'none';\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === 'ltr' ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1),\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', stopScrubbing);\n      document.addEventListener('touchmove', onTouchMove);\n      document.addEventListener('touchend', stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', stopScrubbing);\n      document.removeEventListener('touchmove', onTouchMove);\n      document.removeEventListener('touchend', stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof handlers?.onScrubStart === 'function' && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof handlers?.onScrubEnd === 'function' && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = (event: MouseEvent) => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => onScrub({ x: event.clientX, y: event.clientY });\n\n    const onTouchStart = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\n    };\n\n    ref.current.addEventListener('mousedown', onMouseDown);\n    ref.current.addEventListener('touchstart', onTouchStart, { passive: false });\n\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener('mousedown', onMouseDown);\n        ref.current.removeEventListener('touchstart', onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n\n  return { ref, active };\n}\n"]},"metadata":{},"sourceType":"module"}