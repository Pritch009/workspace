{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction round(number) {\n  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10 ** digits;\n  return Math.round(base * number) / base;\n}\nfunction hslaToHsva(_ref) {\n  let {\n    h,\n    s,\n    l,\n    a\n  } = _ref;\n  const ss = s * ((l < 50 ? l : 100 - l) / 100);\n  return {\n    h,\n    s: ss > 0 ? 2 * ss / (l + ss) * 100 : 0,\n    v: l + ss,\n    a\n  };\n}\nconst angleUnits = {\n  grad: 360 / 400,\n  turn: 360,\n  rad: 360 / (Math.PI * 2)\n};\nfunction parseHue(value) {\n  let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"deg\";\n  return Number(value) * (angleUnits[unit] || 1);\n}\nconst HSL_REGEXP = /hsla?\\(?\\s*(-?\\d*\\.?\\d+)(deg|rad|grad|turn)?[,\\s]+(-?\\d*\\.?\\d+)%?[,\\s]+(-?\\d*\\.?\\d+)%?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\nfunction parseHsla(color) {\n  const match = HSL_REGEXP.exec(color);\n  if (!match) {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n  return hslaToHsva({\n    h: parseHue(match[1], match[2]),\n    s: Number(match[3]),\n    l: Number(match[4]),\n    a: match[5] === void 0 ? 1 : Number(match[5]) / (match[6] ? 100 : 1)\n  });\n}\nfunction rgbaToHsva(_ref2) {\n  let {\n    r,\n    g,\n    b,\n    a\n  } = _ref2;\n  const max = Math.max(r, g, b);\n  const delta = max - Math.min(r, g, b);\n  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;\n  return {\n    h: round(60 * (hh < 0 ? hh + 6 : hh), 3),\n    s: round(max ? delta / max * 100 : 0, 3),\n    v: round(max / 255 * 100, 3),\n    a\n  };\n}\nfunction parseHex(color) {\n  const hex = color[0] === \"#\" ? color.slice(1) : color;\n  if (hex.length === 3) {\n    return rgbaToHsva({\n      r: parseInt(hex[0] + hex[0], 16),\n      g: parseInt(hex[1] + hex[1], 16),\n      b: parseInt(hex[2] + hex[2], 16),\n      a: 1\n    });\n  }\n  return rgbaToHsva({\n    r: parseInt(hex.slice(0, 2), 16),\n    g: parseInt(hex.slice(2, 4), 16),\n    b: parseInt(hex.slice(4, 6), 16),\n    a: 1\n  });\n}\nfunction parseHexa(color) {\n  const hex = color[0] === \"#\" ? color.slice(1) : color;\n  const roundA = a2 => round(parseInt(a2, 16) / 255, 3);\n  if (hex.length === 4) {\n    const withoutOpacity2 = hex.slice(0, 3);\n    const a2 = roundA(hex[3] + hex[3]);\n    const hsvaColor2 = __spreadProps(__spreadValues({}, parseHex(withoutOpacity2)), {\n      a: a2\n    });\n    return hsvaColor2;\n  }\n  const withoutOpacity = hex.slice(0, 6);\n  const a = roundA(hex.slice(6, 8));\n  const hsvaColor = __spreadProps(__spreadValues({}, parseHex(withoutOpacity)), {\n    a\n  });\n  return hsvaColor;\n}\nconst RGB_REGEXP = /rgba?\\(?\\s*(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\nfunction parseRgba(color) {\n  const match = RGB_REGEXP.exec(color);\n  if (!match) {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n  return rgbaToHsva({\n    r: Number(match[1]) / (match[2] ? 100 / 255 : 1),\n    g: Number(match[3]) / (match[4] ? 100 / 255 : 1),\n    b: Number(match[5]) / (match[6] ? 100 / 255 : 1),\n    a: match[7] === void 0 ? 1 : Number(match[7]) / (match[8] ? 100 : 1)\n  });\n}\nconst VALIDATION_REGEXP = {\n  hex: /^#?([0-9A-F]{3}){1,2}$/i,\n  hexa: /^#?([0-9A-F]{4}){1,2}$/i,\n  rgb: /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  rgba: /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  hsl: /hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\)/i,\n  hsla: /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*(\\d*(?:\\.\\d+)?)\\)$/i\n};\nconst CONVERTERS = {\n  hex: parseHex,\n  hexa: parseHexa,\n  rgb: parseRgba,\n  rgba: parseRgba,\n  hsl: parseHsla,\n  hsla: parseHsla\n};\nfunction isColorValid(color) {\n  for (const [, regexp] of Object.entries(VALIDATION_REGEXP)) {\n    if (regexp.test(color)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction parseColor(color) {\n  if (typeof color !== \"string\") {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n  if (color === \"transparent\") {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 0\n    };\n  }\n  const trimmed = color.trim();\n  for (const [rule, regexp] of Object.entries(VALIDATION_REGEXP)) {\n    if (regexp.test(trimmed)) {\n      return CONVERTERS[rule](trimmed);\n    }\n  }\n  return {\n    h: 0,\n    s: 0,\n    v: 0,\n    a: 1\n  };\n}\nexport { isColorValid, parseColor, parseHex, parseHexa, parseHsla, parseHue, parseRgba, round };","map":{"version":3,"sources":["../../../src/ColorPicker/converters/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { HsvaColor, RgbaColor, ColorFormat } from '../types';\n\nexport function round(number: number, digits = 0, base = 10 ** digits) {\n  return Math.round(base * number) / base;\n}\n\nfunction hslaToHsva({ h, s, l, a }): HsvaColor {\n  const ss = s * ((l < 50 ? l : 100 - l) / 100);\n\n  return {\n    h,\n    s: ss > 0 ? ((2 * ss) / (l + ss)) * 100 : 0,\n    v: l + ss,\n    a,\n  };\n}\n\nconst angleUnits: Record<string, number> = {\n  grad: 360 / 400,\n  turn: 360,\n  rad: 360 / (Math.PI * 2),\n};\n\nexport function parseHue(value: string, unit = 'deg') {\n  return Number(value) * (angleUnits[unit] || 1);\n}\n\nconst HSL_REGEXP =\n  /hsla?\\(?\\s*(-?\\d*\\.?\\d+)(deg|rad|grad|turn)?[,\\s]+(-?\\d*\\.?\\d+)%?[,\\s]+(-?\\d*\\.?\\d+)%?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n\nexport function parseHsla(color: string): HsvaColor {\n  const match = HSL_REGEXP.exec(color);\n\n  if (!match) {\n    return { h: 0, s: 0, v: 0, a: 1 };\n  }\n\n  return hslaToHsva({\n    h: parseHue(match[1], match[2]),\n    s: Number(match[3]),\n    l: Number(match[4]),\n    a: match[5] === undefined ? 1 : Number(match[5]) / (match[6] ? 100 : 1),\n  });\n}\n\nfunction rgbaToHsva({ r, g, b, a }: RgbaColor): HsvaColor {\n  const max = Math.max(r, g, b);\n  const delta = max - Math.min(r, g, b);\n\n  const hh = delta\n    ? max === r\n      ? (g - b) / delta\n      : max === g\n      ? 2 + (b - r) / delta\n      : 4 + (r - g) / delta\n    : 0;\n\n  return {\n    h: round(60 * (hh < 0 ? hh + 6 : hh), 3),\n    s: round(max ? (delta / max) * 100 : 0, 3),\n    v: round((max / 255) * 100, 3),\n    a,\n  };\n}\n\nexport function parseHex(color: string): HsvaColor {\n  const hex = color[0] === '#' ? color.slice(1) : color;\n\n  if (hex.length === 3) {\n    return rgbaToHsva({\n      r: parseInt(hex[0] + hex[0], 16),\n      g: parseInt(hex[1] + hex[1], 16),\n      b: parseInt(hex[2] + hex[2], 16),\n      a: 1,\n    });\n  }\n\n  return rgbaToHsva({\n    r: parseInt(hex.slice(0, 2), 16),\n    g: parseInt(hex.slice(2, 4), 16),\n    b: parseInt(hex.slice(4, 6), 16),\n    a: 1,\n  });\n}\n\nexport function parseHexa(color: string): HsvaColor {\n  const hex = color[0] === '#' ? color.slice(1) : color;\n\n  const roundA = (a: string) => round(parseInt(a, 16) / 255, 3);\n  if (hex.length === 4) {\n    const withoutOpacity = hex.slice(0, 3);\n    const a = roundA(hex[3] + hex[3]);\n\n    const hsvaColor: HsvaColor = { ...parseHex(withoutOpacity), a };\n    return hsvaColor;\n  }\n\n  const withoutOpacity = hex.slice(0, 6);\n  const a = roundA(hex.slice(6, 8));\n  const hsvaColor: HsvaColor = { ...parseHex(withoutOpacity), a };\n  return hsvaColor;\n}\n\nconst RGB_REGEXP =\n  /rgba?\\(?\\s*(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n\nexport function parseRgba(color: string): HsvaColor {\n  const match = RGB_REGEXP.exec(color);\n\n  if (!match) {\n    return { h: 0, s: 0, v: 0, a: 1 };\n  }\n\n  return rgbaToHsva({\n    r: Number(match[1]) / (match[2] ? 100 / 255 : 1),\n    g: Number(match[3]) / (match[4] ? 100 / 255 : 1),\n    b: Number(match[5]) / (match[6] ? 100 / 255 : 1),\n    a: match[7] === undefined ? 1 : Number(match[7]) / (match[8] ? 100 : 1),\n  });\n}\n\nconst VALIDATION_REGEXP: Record<ColorFormat, RegExp> = {\n  hex: /^#?([0-9A-F]{3}){1,2}$/i,\n  hexa: /^#?([0-9A-F]{4}){1,2}$/i,\n  rgb: /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  rgba: /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  hsl: /hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\)/i,\n  hsla: /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*(\\d*(?:\\.\\d+)?)\\)$/i,\n};\n\nconst CONVERTERS: Record<ColorFormat, (color: string) => HsvaColor> = {\n  hex: parseHex,\n  hexa: parseHexa,\n  rgb: parseRgba,\n  rgba: parseRgba,\n  hsl: parseHsla,\n  hsla: parseHsla,\n};\n\nexport function isColorValid(color: string) {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [, regexp] of Object.entries(VALIDATION_REGEXP)) {\n    if (regexp.test(color)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function parseColor(color: string): HsvaColor {\n  if (typeof color !== 'string') {\n    return { h: 0, s: 0, v: 0, a: 1 };\n  }\n\n  if (color === 'transparent') {\n    return { h: 0, s: 0, v: 0, a: 0 };\n  }\n\n  const trimmed = color.trim();\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [rule, regexp] of Object.entries(VALIDATION_REGEXP)) {\n    if (regexp.test(trimmed)) {\n      return CONVERTERS[rule](trimmed);\n    }\n  }\n\n  return { h: 0, s: 0, v: 0, a: 1 };\n}\n"]},"metadata":{},"sourceType":"module"}